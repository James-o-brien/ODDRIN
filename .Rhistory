library("rstan")
library(bayesplot)
library(mvtnorm)
library(dplyr)
library(gridExtra)
library(ExtDist)
options(mc.cores=4)
rm(list = ls())
library(rstan)
library(dplyr)
options(mc.cores=4)
eta = 1
type = 2
n_float = 20
n_items = 8
n_iter = 2000
data_coarsened_all_items = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/HPC/coarsened_all_items_v2')
data.loc <- data_coarsened_all_items$data.loc
data.y <- data_coarsened_all_items$data.m
unique_forms = unique(data_coarsened_all_items$data.items)
data.n_forms = c(sapply(unique_forms, function(x)sum(data_coarsened_all_items$data.items==x)))
#actual floating profiles
to.float <- c(1,2,3,4,5,16,17,23,26,29,30,32,36,38,43,45,46,49,51,52,54,55,56,60,61,62,65,68,69,70,71,73,75,79,80,99,100,106,110,114,115,130,136,140,154,164,165,167,168,169,175,177,180,181,183,184,186,188,189,192,193,194,196,198,200,201,202,204,206,207,210,212,213,215,217,219,220,221,222,223,225,226,227,234,235,236,237,238,240,243,246,247,257,259,260,277,278,287,299,300,302,303,314,316,319,320,322,325,357,358,361,365,382,398,405,410,411,419,422,423,425,426,432,434,435,454,461,473,474,476,477,479,488,491,492,494,495,496,497,498,500,501,503,504,505,506,507,508,509,510,511,512,514,515,516,517,519,527,529,530,531,534,536,537,539,540,541,549,550,551,552,553,554,556,557,558,559,560,561,577,578,579,580,581,582,583,584,587,588,591,593,597,603,605,652,661,676,677,678,699,704,709,714,715,717,718,726,729,730,736,737,738,742,752,755,761,763,764,766,767,804,901,905,908,910,912,913,927,1002,1300,1352,4218,4239,4245,4285,4286,4289,4675,4682,4685,7550,7591,7592,7593,7600,7610,7980)
# alternative selection of floating profiles that are better mixed with the anchor profiles
# to.float <- c(1,5,23,29,30,32,38,45,51,54,55,61,65,68,70,71,73,110,114,115,130,136,140,154, 164,165,167,168,169,175,177,180,181,186,188,192,196,201,206,210,212,213,217,220,221,223,225,234, 235,236,237,238,246,257,259,278,287,299,300,302,303,319,325,358,361,365,419,422,423,425,434,435, 479,488,492,498,504,505,506,507,510,511,515,516,517,531,534,537,540,549,554,558,559,561,577,578, 579,580,581,587,603,676,714,717,718,730,738,742,752,767,910,1002,4218,4285,4286,4675,4682,4685,7550,7591,7600,7610,7980)
if (type == 1){
to.float <- to.float[1:n_float]
}
float_indexes = which(data.loc[,1] %in% to.float)
#generate the inducing points
inducing_points = expand.grid(seq(0,1, length.out=11),  seq(0,0.9, length.out=10))
n_inducing_points = NROW(inducing_points)
#select which items will be used for inference
item_prevalence = c()
for (i in 1:length(data.n_forms)){
item_prevalence = c(item_prevalence, sum(data.y[(sum(data.n_forms[0:(i-1)])+1):sum(data.n_forms[1:i]),]))
}
#items_used = sort(item_prevalence, index.return=TRUE, decreasing=TRUE)$ix[1:n_items]
# original 8 items = c(26,24,4,23,65,71,20,12)
items_used = c(26,24,4,23,65,71,20,12)
items_used = sort(items_used)
#obtain the indexes of the y data corresponding to these items
y_form_indexes= c()
for (i in items_used){
y_form_indexes = c(y_form_indexes,(sum(data.n_forms[0:(i-1)])+1):sum(data.n_forms[1:i]))
}
#sort y data into anchor profiles followed by floating profiles
y.sort = cbind(data.y[y_form_indexes,-float_indexes], data.y[y_form_indexes,float_indexes[1:n_float]])
data.loc.float = sweep(data.loc[float_indexes[1:n_float],2:3], 2, c(350,275)) / 200
data.loc.anchor = sweep(data.loc[-float_indexes,2:3],2, c(350,275)) / 200
smi_fit_part1 = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/HPC April/fit_smi_l0.5_Q5_iter2000_eta0.2_items8_float100_type2')
Rhat = summary(smi_fit_part1, pars = c('mu', 'zeta', 'floating_locs', 'phi'))$summary[,10]
Rhat[rev(order(Rhat))]
log_lik = extract(smi_fit_part1, 'log_lik')[[1]][,1:120,]
dim(log_lik) = c(4500, 120 * sum(data.n_forms[items_used]))
loo::waic(log_lik)
smi_fit_part1 = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/HPC April/fit_smi_l0.5_Q5_iter2000_eta0.5_items8_float100_type2')
#Print the Rhat values for mu, zeta, phi and \tilde{X_{\bar{A}}}
Rhat = summary(smi_fit_part1, pars = c('mu', 'zeta', 'floating_locs', 'phi'))$summary[,10]
Rhat[rev(order(Rhat))]
log_lik = extract(smi_fit_part1, 'log_lik')[[1]][,1:120,]
dim(log_lik) = c(4500, 120 * sum(data.n_forms[items_used]))
loo::waic(log_lik)
smi_fit_part1 = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/HPC April/fit_smi_l0.5_Q5_iter2000_eta1_items8_float100_type2')
rm(list = ls())
library("rstan")
library(bayesplot)
library(mvtnorm)
library(dplyr)
library(gridExtra)
library(ExtDist)
options(mc.cores=4)
rm(list = ls())
library(rstan)
library(dplyr)
options(mc.cores=4)
eta = 1
type = 2
n_float = 20
n_items = 8
n_iter = 2000
data_coarsened_all_items = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/HPC/coarsened_all_items_v2')
data.loc <- data_coarsened_all_items$data.loc
data.y <- data_coarsened_all_items$data.m
unique_forms = unique(data_coarsened_all_items$data.items)
data.n_forms = c(sapply(unique_forms, function(x)sum(data_coarsened_all_items$data.items==x)))
#actual floating profiles
to.float <- c(1,2,3,4,5,16,17,23,26,29,30,32,36,38,43,45,46,49,51,52,54,55,56,60,61,62,65,68,69,70,71,73,75,79,80,99,100,106,110,114,115,130,136,140,154,164,165,167,168,169,175,177,180,181,183,184,186,188,189,192,193,194,196,198,200,201,202,204,206,207,210,212,213,215,217,219,220,221,222,223,225,226,227,234,235,236,237,238,240,243,246,247,257,259,260,277,278,287,299,300,302,303,314,316,319,320,322,325,357,358,361,365,382,398,405,410,411,419,422,423,425,426,432,434,435,454,461,473,474,476,477,479,488,491,492,494,495,496,497,498,500,501,503,504,505,506,507,508,509,510,511,512,514,515,516,517,519,527,529,530,531,534,536,537,539,540,541,549,550,551,552,553,554,556,557,558,559,560,561,577,578,579,580,581,582,583,584,587,588,591,593,597,603,605,652,661,676,677,678,699,704,709,714,715,717,718,726,729,730,736,737,738,742,752,755,761,763,764,766,767,804,901,905,908,910,912,913,927,1002,1300,1352,4218,4239,4245,4285,4286,4289,4675,4682,4685,7550,7591,7592,7593,7600,7610,7980)
# alternative selection of floating profiles that are better mixed with the anchor profiles
# to.float <- c(1,5,23,29,30,32,38,45,51,54,55,61,65,68,70,71,73,110,114,115,130,136,140,154, 164,165,167,168,169,175,177,180,181,186,188,192,196,201,206,210,212,213,217,220,221,223,225,234, 235,236,237,238,246,257,259,278,287,299,300,302,303,319,325,358,361,365,419,422,423,425,434,435, 479,488,492,498,504,505,506,507,510,511,515,516,517,531,534,537,540,549,554,558,559,561,577,578, 579,580,581,587,603,676,714,717,718,730,738,742,752,767,910,1002,4218,4285,4286,4675,4682,4685,7550,7591,7600,7610,7980)
if (type == 1){
to.float <- to.float[1:n_float]
}
float_indexes = which(data.loc[,1] %in% to.float)
#generate the inducing points
inducing_points = expand.grid(seq(0,1, length.out=11),  seq(0,0.9, length.out=10))
n_inducing_points = NROW(inducing_points)
#select which items will be used for inference
item_prevalence = c()
for (i in 1:length(data.n_forms)){
item_prevalence = c(item_prevalence, sum(data.y[(sum(data.n_forms[0:(i-1)])+1):sum(data.n_forms[1:i]),]))
}
#items_used = sort(item_prevalence, index.return=TRUE, decreasing=TRUE)$ix[1:n_items]
# original 8 items = c(26,24,4,23,65,71,20,12)
items_used = c(26,24,4,23,65,71,20,12)
items_used = sort(items_used)
#obtain the indexes of the y data corresponding to these items
y_form_indexes= c()
for (i in items_used){
y_form_indexes = c(y_form_indexes,(sum(data.n_forms[0:(i-1)])+1):sum(data.n_forms[1:i]))
}
#sort y data into anchor profiles followed by floating profiles
y.sort = cbind(data.y[y_form_indexes,-float_indexes], data.y[y_form_indexes,float_indexes[1:n_float]])
data.loc.float = sweep(data.loc[float_indexes[1:n_float],2:3], 2, c(350,275)) / 200
data.loc.anchor = sweep(data.loc[-float_indexes,2:3],2, c(350,275)) / 200
locations = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/HPC April/mod2_anchor120_iter750_items8_type2_eta0')
plot_density_tiles <- function(location_samples, fittech_location){
df = data.frame(location_samples)
ggplot(df, aes(x=X1, y=X2) ) +
scale_x_continuous(lim=c(-0.05,1.05), expand = c(0, -0.05)) +
scale_y_continuous(lim=c(-0.05,0.95), expand = c(0, -0.05)) +
geom_bin2d(bins=c(22,20)) +
theme_bw() +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
legend.position='none', plot.margin=unit(c(0,0,0, 0),"cm"),
axis.ticks.x = element_blank(), axis.text.x = element_blank(),
axis.ticks.y = element_blank(), axis.text.y = element_blank()) +
xlab('') + ylab('') +
scale_fill_continuous(low="white", high="#00AEFF") + coord_fixed() +
geom_point(x=fittech_location[1], y=fittech_location[2], col='red', shape=4, size=3)
}
#plot the posterior samples of the first 10 anchor locations compared to the fit-technique locations
estloc_plots <- vector('list', 10)
for (i in 1:10) {
estloc_plots[[i]] <- local({
i <- i
p1 <- plot_density_tiles(locations[,i,], data.loc.anchor[i,])
print(p1)
})
}
grid.arrange(grobs = estloc_plots, ncol = 5, nrow=2)
plot_density_tiles <- function(location_samples, fittech_location){
df = data.frame(location_samples)
ggplot(df, aes(x=X1, y=X2) ) +
scale_x_continuous(lim=c(-0.05,1.05), expand = c(0, -0.05)) +
scale_y_continuous(lim=c(-0.05,0.95), expand = c(0, -0.05)) +
geom_bin2d(bins=c(22,20)) +
theme_bw() +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
legend.position='none', plot.margin=unit(c(0,0,0, 0),"cm"),
axis.ticks.x = element_blank(), axis.text.x = element_blank(),
axis.ticks.y = element_blank(), axis.text.y = element_blank()) +
xlab('') + ylab('') +
scale_fill_continuous(low="white", high="#00AEFF") + coord_fixed() +
geom_point(x=fittech_location[1], y=fittech_location[2], col='red', shape=4, size=3)
}
#plot the posterior samples of the first 10 anchor locations compared to the fit-technique locations
estloc_plots <- vector('list', 20)
for (i in 1:20) {
estloc_plots[[i]] <- local({
i <- i
p1 <- plot_density_tiles(locations[,i,], data.loc.anchor[i,])
print(p1)
})
}
grid.arrange(grobs = estloc_plots, ncol = 5, nrow=2)
grid.arrange(grobs = estloc_plots, ncol = 5, nrow=4)
estloc_plots <- vector('list', 20)
for (i in 1:20) {
estloc_plots[[i]] <- local({
i <- i
p1 <- plot_density_tiles(locations[,i,], data.loc.float[i,])
print(p1)
})
}
grid.arrange(grobs = estloc_plots, ncol = 5, nrow=4)
locations = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/HPC April/mod2_anchor120_iter750_items8_type2_eta0.5')
dist_to_anchor = function(location_sample){
sqrt(rowSums((location_sample - data.loc.anchor)^2))
}
mean(apply(apply(locations, 1, dist_to_anchor), 1, mean))
plot_density_tiles <- function(location_samples, fittech_location){
df = data.frame(location_samples)
ggplot(df, aes(x=X1, y=X2) ) +
scale_x_continuous(lim=c(-0.05,1.05), expand = c(0, -0.05)) +
scale_y_continuous(lim=c(-0.05,0.95), expand = c(0, -0.05)) +
geom_bin2d(bins=c(22,20)) +
theme_bw() +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
legend.position='none', plot.margin=unit(c(0,0,0, 0),"cm"),
axis.ticks.x = element_blank(), axis.text.x = element_blank(),
axis.ticks.y = element_blank(), axis.text.y = element_blank()) +
xlab('') + ylab('') +
scale_fill_continuous(low="white", high="#00AEFF") + coord_fixed() +
geom_point(x=fittech_location[1], y=fittech_location[2], col='red', shape=4, size=3)
}
#plot the posterior samples of the first 10 anchor locations compared to the fit-technique locations
estloc_plots <- vector('list', 20)
for (i in 1:20) {
estloc_plots[[i]] <- local({
i <- i
p1 <- plot_density_tiles(locations[,i,], data.loc.float[i,])
print(p1)
})
}
grid.arrange(grobs = estloc_plots, ncol = 5, nrow=4)
locations = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/HPC April/mod2_anchor120_iter750_items8_type2_eta0.5')
locations
locations = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/HPC April/mod2_anchor120_iter750_items8_type2_eta0.2')
plot_density_tiles <- function(location_samples, fittech_location){
df = data.frame(location_samples)
ggplot(df, aes(x=X1, y=X2) ) +
scale_x_continuous(lim=c(-0.05,1.05), expand = c(0, -0.05)) +
scale_y_continuous(lim=c(-0.05,0.95), expand = c(0, -0.05)) +
geom_bin2d(bins=c(22,20)) +
theme_bw() +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
legend.position='none', plot.margin=unit(c(0,0,0, 0),"cm"),
axis.ticks.x = element_blank(), axis.text.x = element_blank(),
axis.ticks.y = element_blank(), axis.text.y = element_blank()) +
xlab('') + ylab('') +
scale_fill_continuous(low="white", high="#00AEFF") + coord_fixed() +
geom_point(x=fittech_location[1], y=fittech_location[2], col='red', shape=4, size=3)
}
#plot the posterior samples of the first 10 anchor locations compared to the fit-technique locations
estloc_plots <- vector('list', 20)
for (i in 1:20) {
estloc_plots[[i]] <- local({
i <- i
p1 <- plot_density_tiles(locations[,i,], data.loc.float[i,])
print(p1)
})
}
grid.arrange(grobs = estloc_plots, ncol = 5, nrow=4)
locations = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/HPC April/mod2_anchor120_iter750_items8_type2_eta0.1')
plot_density_tiles <- function(location_samples, fittech_location){
df = data.frame(location_samples)
ggplot(df, aes(x=X1, y=X2) ) +
scale_x_continuous(lim=c(-0.05,1.05), expand = c(0, -0.05)) +
scale_y_continuous(lim=c(-0.05,0.95), expand = c(0, -0.05)) +
geom_bin2d(bins=c(22,20)) +
theme_bw() +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
legend.position='none', plot.margin=unit(c(0,0,0, 0),"cm"),
axis.ticks.x = element_blank(), axis.text.x = element_blank(),
axis.ticks.y = element_blank(), axis.text.y = element_blank()) +
xlab('') + ylab('') +
scale_fill_continuous(low="white", high="#00AEFF") + coord_fixed() +
geom_point(x=fittech_location[1], y=fittech_location[2], col='red', shape=4, size=3)
}
#plot the posterior samples of the first 10 anchor locations compared to the fit-technique locations
estloc_plots <- vector('list', 20)
for (i in 1:20) {
estloc_plots[[i]] <- local({
i <- i
p1 <- plot_density_tiles(locations[,i,], data.loc.float[i,])
print(p1)
})
}
grid.arrange(grobs = estloc_plots, ncol = 5, nrow=4)
smi_fit_part1 = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/HPC April/fit_smi_l0.5_Q5_iter2000_eta1_items8_float100_type2')
smi_fit_part1 = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/HPC April/fit_smi_l0.5_Q5_iter2000_eta1_items8_float100_type2')
smi_fit_part1 = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/fit_smi_l0.5_Q5_iter2000_eta1_items8_float100_type2')
locations = as.array(smi_fit_part1, pars='floating_locs')
dim(locations) = c(1500 * 3, 100,2)
plot_density_tiles <- function(location_samples, fittech_location){
df = data.frame(location_samples)
ggplot(df, aes(x=X1, y=X2) ) +
scale_x_continuous(lim=c(-0.05,1.05), expand = c(0, -0.05)) +
scale_y_continuous(lim=c(-0.05,0.95), expand = c(0, -0.05)) +
geom_bin2d(bins=c(22,20)) +
theme_bw() +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
legend.position='none', plot.margin=unit(c(0,0,0, 0),"cm"),
axis.ticks.x = element_blank(), axis.text.x = element_blank(),
axis.ticks.y = element_blank(), axis.text.y = element_blank()) +
xlab('') + ylab('') +
scale_fill_continuous(low="white", high="#00AEFF") + coord_fixed() +
geom_point(x=fittech_location[1], y=fittech_location[2], col='red', shape=4, size=3)
}
#plot posterior samples of the first 10 locations compared with the fit-technique estimates
estloc_plots <- vector('list', 20)
for (i in 1:20) {
estloc_plots[[i]] <- local({
i <- i
p <- plot_density_tiles(locations[,i,], data.loc.float[i,])
print(p)
})
}
grid.arrange(grobs = estloc_plots, ncol = 5, nrow=4)
rm(list=ls())
# Where is the main folder with all the code and data
dir<-directory<-"/home/manderso/Documents/GitHub/ODDRIN/"
# Set the working directory from your environment variables
setwd(directory)
# Directory of the Data for Good data, e.g. Disaster Mapping, 4G connectivity, etc
FBdirectory<-'/home/patten/Documents/IDMC/Facebook_Data/'
# Do you want only the reduced packages or all? Choose via packred
packred<-F
source('RCode/GetEnv.R')
# Download and install the necessary packages:
source('RCode/GetODDPackages.R')
# Sourcing the data:
source('RCode/GetData.R')
# Extract model functions and priors
source('RCode/Model.R')
# Extract the model parameterisation algorithm, default = Adaptive MCMC
source('RCode/Method.R')
#Extract the functions for generating the simulations
source('RCode/Simulate.R')
Omega <- list(Lambda1 = list(nu=1,omega=0.1),
Lambda2 = list(nu= 0.15, omega=0.75),
Lambda3 = list(nu=0.7,omega=0.05),
zeta = list(k=2.978697, lambda=1.405539),
Pdens = list(M=0.02988616, k = 6.473428),
dollar = list(M = -1.051271, k = 6.473428),
theta = list(e=0.2359788),
eps = list(eps=0.01304351))
output <- readRDS('/home/manderso/Documents/GitHub/ODDRIN/IIDIPUS_Results/output_2022-04-26_234345')
Omega_MAP <- output[which.max(output[,1]),2:ncol(output)] %>%
relist(skeleton=Model$skeleton) %>% unlist() %>% Proposed2Physical(Model)
Intensity <- seq(0,10,0.1)
Dfun<-function(I_ij, theta) h_0(I = I_ij,I0 = 4.5,theta = Omega$theta)
D_extent <- BinR(Dfun(Intensity, theta=Omega$theta) , Omega$zeta)
D_extent_sample <- BinR(Dfun(Intensity, theta=Omega_MAP$theta) , Omega_MAP$zeta)
D_MortDisp <- BinR( Omega$Lambda1$nu * Dfun(Intensity, theta=Omega$theta) + Omega$Lambda1$omega, Omega$zeta)
D_MortDisp_sample <- BinR( Omega_MAP$Lambda1$nu * Dfun(Intensity, theta=Omega_MAP$theta) + Omega_MAP$Lambda1$omega, Omega_MAP$zeta)
D_Mort <- BinR(Omega$Lambda2$nu * Dfun(Intensity, theta=Omega$theta) + Omega$Lambda2$omega , Omega$zeta) * D_MortDisp
D_Mort_sample <- BinR(Omega_MAP$Lambda2$nu * Dfun(Intensity, theta=Omega_MAP$theta) + Omega_MAP$Lambda2$omega , Omega_MAP$zeta) * D_MortDisp_sample
D_Disp <- D_MortDisp - D_Mort
D_Disp_sample <- D_MortDisp_sample - D_Mort_sample
D_BD <- BinR(Omega$Lambda3$nu * Dfun(Intensity, theta=Omega$theta) + Omega$Lambda3$omega, Omega$zeta)
D_BD_sample <- BinR(Omega_MAP$Lambda3$nu * Dfun(Intensity, theta=Omega_MAP$theta) + Omega_MAP$Lambda3$omega, Omega_MAP$zeta)
plot(Intensity, D_Mort, col='red', type='l', ylim=c(0,1)); lines(Intensity, D_Mort_sample, col='red', lty=2)
lines(Intensity, D_Disp, col='blue'); lines(Intensity, D_Disp_sample, col='blue', lty=2)
lines(Intensity, D_BD, col='pink', type='l'); lines(Intensity, D_BD_sample, col='pink', lty=2, lwd=2)
lines(Intensity, D_extent, col='green', type='l'); lines(Intensity, D_extent_sample, col='green', lty=2, lwd=2)
#check that the likelihood from the true parameters is not greater than the MAP estimate
logTarget(dir = dir,Model = Model,proposed = Omega_MAP, AlgoParams = AlgoParams)
logTarget(dir = dir,Model = Model,proposed = Omega, AlgoParams = AlgoParams)
plot(output[,2])
plot(output[1:1500,2])
plot(output[1:1500,2], type='l')
plot(output[1:1500,3], type='l')
plot(output[1:1500,4], type='l')
plot(output[1:1500,5], type='l')
plot(output[1:1500,6], type='l')
plot(output[1:1500,7], type='l')
plot(output[1:1500,8], type='l')
plot(output[1:1500,9], type='l')
#check that the likelihood from the true parameters is not greater than the MAP estimate
logTarget(dir = dir,Model = Model,proposed = Omega_MAP, AlgoParams = AlgoParams)
logTarget(dir = dir,Model = Model,proposed = Omega, AlgoParams = AlgoParams)
proposed = Omega
DispX(ODD = ODDy,Omega = proposed,center = Model$center, BD_params = Model$BD_params, LL = T,Method = AlgoParams)
folderin<-paste0(dir,"IIDIPUS_Input/ODDobjects/")
ufiles<-na.omit(list.files(path=folderin,pattern=Model$haz,recursive = T,ignore.case = T)) #looseend
i = 1
# Extract the ODD object
ODDy<-readRDS(paste0(folderin,ufiles[i]))
# Backdated version control: old IIDIPUS depended on ODDy$fIndies values and gmax different format
ODDy@fIndies<-Model$fIndies
ODDy@gmax%<>%as.data.frame.list()
# Apply DispX
tLL<-tryCatch(DispX(ODD = ODDy,Omega = proposed,center = Model$center, BD_params = Model$BD_params, LL = T,Method = AlgoParams),
error=function(e) NA)
tLL
folderin<-paste0(dir,"IIDIPUS_Input/BDobjects/")
ufiles<-list.files(path=folderin,pattern=Model$haz,recursive = T,ignore.case = T)
BDy<-readRDS(paste0(folderin,ufiles[i]))
# Backdated version control: old IIDIPUS depended on ODDy$fIndies values and gmax different format
BDy@fIndies<-Model$fIndies
# Apply BDX
tLL<-tryCatch(BDX(BD = BDy,Omega = proposed,Model = Model,Method=AlgoParams, LL=T),
error=function(e) NA)
tLL
# Add the log-likelihood values from the ODD (displacement) objects
LL<-LL_Displacement(0,dir,Model,proposed,AlgoParams,expLL=T)
# Add the log-likelihood values from the BD (building damage) objects
LL%<>%LL_Buildings(dir,Model,proposed,AlgoParams,expLL=T)
LL
#check that the likelihood from the true parameters is not greater than the MAP estimate
logTarget(dir = dir,Model = Model,proposed = Omega_MAP, AlgoParams = AlgoParams)
dir
Model
Omega_MAP
AlgoParams
AlgoParams$ABC <- 1
logTarget(dir = dir,Model = Model,proposed = Omega_MAP, AlgoParams = AlgoParams)
logTarget(dir = dir,Model = Model,proposed = Omega, AlgoParams = AlgoParams)
rm(list = ls())
library("rstan")
library(bayesplot)
library(mvtnorm)
library(dplyr)
library(gridExtra)
library(ExtDist)
options(mc.cores=4)
rm(list = ls())
library(rstan)
library(dplyr)
options(mc.cores=4)
eta = 1
type = 2
n_float = 20
n_items = 8
n_iter = 2000
data_coarsened_all_items = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/HPC/coarsened_all_items_v2')
data.loc <- data_coarsened_all_items$data.loc
data.y <- data_coarsened_all_items$data.m
unique_forms = unique(data_coarsened_all_items$data.items)
data.n_forms = c(sapply(unique_forms, function(x)sum(data_coarsened_all_items$data.items==x)))
#actual floating profiles
to.float <- c(1,2,3,4,5,16,17,23,26,29,30,32,36,38,43,45,46,49,51,52,54,55,56,60,61,62,65,68,69,70,71,73,75,79,80,99,100,106,110,114,115,130,136,140,154,164,165,167,168,169,175,177,180,181,183,184,186,188,189,192,193,194,196,198,200,201,202,204,206,207,210,212,213,215,217,219,220,221,222,223,225,226,227,234,235,236,237,238,240,243,246,247,257,259,260,277,278,287,299,300,302,303,314,316,319,320,322,325,357,358,361,365,382,398,405,410,411,419,422,423,425,426,432,434,435,454,461,473,474,476,477,479,488,491,492,494,495,496,497,498,500,501,503,504,505,506,507,508,509,510,511,512,514,515,516,517,519,527,529,530,531,534,536,537,539,540,541,549,550,551,552,553,554,556,557,558,559,560,561,577,578,579,580,581,582,583,584,587,588,591,593,597,603,605,652,661,676,677,678,699,704,709,714,715,717,718,726,729,730,736,737,738,742,752,755,761,763,764,766,767,804,901,905,908,910,912,913,927,1002,1300,1352,4218,4239,4245,4285,4286,4289,4675,4682,4685,7550,7591,7592,7593,7600,7610,7980)
# alternative selection of floating profiles that are better mixed with the anchor profiles
# to.float <- c(1,5,23,29,30,32,38,45,51,54,55,61,65,68,70,71,73,110,114,115,130,136,140,154, 164,165,167,168,169,175,177,180,181,186,188,192,196,201,206,210,212,213,217,220,221,223,225,234, 235,236,237,238,246,257,259,278,287,299,300,302,303,319,325,358,361,365,419,422,423,425,434,435, 479,488,492,498,504,505,506,507,510,511,515,516,517,531,534,537,540,549,554,558,559,561,577,578, 579,580,581,587,603,676,714,717,718,730,738,742,752,767,910,1002,4218,4285,4286,4675,4682,4685,7550,7591,7600,7610,7980)
if (type == 1){
to.float <- to.float[1:n_float]
}
float_indexes = which(data.loc[,1] %in% to.float)
#generate the inducing points
inducing_points = expand.grid(seq(0,1, length.out=11),  seq(0,0.9, length.out=10))
n_inducing_points = NROW(inducing_points)
#select which items will be used for inference
item_prevalence = c()
for (i in 1:length(data.n_forms)){
item_prevalence = c(item_prevalence, sum(data.y[(sum(data.n_forms[0:(i-1)])+1):sum(data.n_forms[1:i]),]))
}
#items_used = sort(item_prevalence, index.return=TRUE, decreasing=TRUE)$ix[1:n_items]
# original 8 items = c(26,24,4,23,65,71,20,12)
items_used = c(26,24,4,23,65,71,20,12)
items_used = sort(items_used)
#obtain the indexes of the y data corresponding to these items
y_form_indexes= c()
for (i in items_used){
y_form_indexes = c(y_form_indexes,(sum(data.n_forms[0:(i-1)])+1):sum(data.n_forms[1:i]))
}
#sort y data into anchor profiles followed by floating profiles
y.sort = cbind(data.y[y_form_indexes,-float_indexes], data.y[y_form_indexes,float_indexes[1:n_float]])
data.loc.float = sweep(data.loc[float_indexes[1:n_float],2:3], 2, c(350,275)) / 200
data.loc.anchor = sweep(data.loc[-float_indexes,2:3],2, c(350,275)) / 200
smi_fit_part1 = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/fit_smi_l0.5_Q5_iter2000_eta1_items8_float100_type2')
log_lik = extract(smi_fit_part1, 'log_lik')[[1]][,1:120,]
log_lik = extract(smi_fit_part1, 'log_lik')[[1]][,1:120,]
library("rstan")
library(bayesplot)
library(mvtnorm)
library(dplyr)
library(gridExtra)
library(ExtDist)
options(mc.cores=4)
log_lik = extract(smi_fit_part1, 'log_lik')[[1]][,1:120,]
rm(list = ls())
library("rstan")
library(bayesplot)
library(mvtnorm)
library(dplyr)
library(gridExtra)
library(ExtDist)
options(mc.cores=4)
rm(list = ls())
library(rstan)
library(dplyr)
options(mc.cores=4)
eta = 1
type = 2
n_float = 20
n_items = 8
n_iter = 2000
data_coarsened_all_items = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/HPC/coarsened_all_items_v2')
data.loc <- data_coarsened_all_items$data.loc
data.y <- data_coarsened_all_items$data.m
unique_forms = unique(data_coarsened_all_items$data.items)
data.n_forms = c(sapply(unique_forms, function(x)sum(data_coarsened_all_items$data.items==x)))
#actual floating profiles
to.float <- c(1,2,3,4,5,16,17,23,26,29,30,32,36,38,43,45,46,49,51,52,54,55,56,60,61,62,65,68,69,70,71,73,75,79,80,99,100,106,110,114,115,130,136,140,154,164,165,167,168,169,175,177,180,181,183,184,186,188,189,192,193,194,196,198,200,201,202,204,206,207,210,212,213,215,217,219,220,221,222,223,225,226,227,234,235,236,237,238,240,243,246,247,257,259,260,277,278,287,299,300,302,303,314,316,319,320,322,325,357,358,361,365,382,398,405,410,411,419,422,423,425,426,432,434,435,454,461,473,474,476,477,479,488,491,492,494,495,496,497,498,500,501,503,504,505,506,507,508,509,510,511,512,514,515,516,517,519,527,529,530,531,534,536,537,539,540,541,549,550,551,552,553,554,556,557,558,559,560,561,577,578,579,580,581,582,583,584,587,588,591,593,597,603,605,652,661,676,677,678,699,704,709,714,715,717,718,726,729,730,736,737,738,742,752,755,761,763,764,766,767,804,901,905,908,910,912,913,927,1002,1300,1352,4218,4239,4245,4285,4286,4289,4675,4682,4685,7550,7591,7592,7593,7600,7610,7980)
# alternative selection of floating profiles that are better mixed with the anchor profiles
# to.float <- c(1,5,23,29,30,32,38,45,51,54,55,61,65,68,70,71,73,110,114,115,130,136,140,154, 164,165,167,168,169,175,177,180,181,186,188,192,196,201,206,210,212,213,217,220,221,223,225,234, 235,236,237,238,246,257,259,278,287,299,300,302,303,319,325,358,361,365,419,422,423,425,434,435, 479,488,492,498,504,505,506,507,510,511,515,516,517,531,534,537,540,549,554,558,559,561,577,578, 579,580,581,587,603,676,714,717,718,730,738,742,752,767,910,1002,4218,4285,4286,4675,4682,4685,7550,7591,7600,7610,7980)
if (type == 1){
to.float <- to.float[1:n_float]
}
float_indexes = which(data.loc[,1] %in% to.float)
#generate the inducing points
inducing_points = expand.grid(seq(0,1, length.out=11),  seq(0,0.9, length.out=10))
n_inducing_points = NROW(inducing_points)
#select which items will be used for inference
item_prevalence = c()
for (i in 1:length(data.n_forms)){
item_prevalence = c(item_prevalence, sum(data.y[(sum(data.n_forms[0:(i-1)])+1):sum(data.n_forms[1:i]),]))
}
#items_used = sort(item_prevalence, index.return=TRUE, decreasing=TRUE)$ix[1:n_items]
# original 8 items = c(26,24,4,23,65,71,20,12)
items_used = c(26,24,4,23,65,71,20,12)
items_used = sort(items_used)
#obtain the indexes of the y data corresponding to these items
y_form_indexes= c()
for (i in items_used){
y_form_indexes = c(y_form_indexes,(sum(data.n_forms[0:(i-1)])+1):sum(data.n_forms[1:i]))
}
#sort y data into anchor profiles followed by floating profiles
y.sort = cbind(data.y[y_form_indexes,-float_indexes], data.y[y_form_indexes,float_indexes[1:n_float]])
data.loc.float = sweep(data.loc[float_indexes[1:n_float],2:3], 2, c(350,275)) / 200
data.loc.anchor = sweep(data.loc[-float_indexes,2:3],2, c(350,275)) / 200
smi_fit_part1 = readRDS('/home/manderso/Documents/StatML 2021-22/MiniProject 1/Spatial Texts Stan/fit_smi_l0.5_Q5_iter2000_eta1_items8_float100_type2')
log_lik = extract(smi_fit_part1, 'log_lik')[[1]][,1:120,]
smi_fit_part1
log_lik = extract(smi_fit_part1, 'log_lik')[[1]][,1:120,]
?extract
log_lik = rstan::extract(smi_fit_part1, 'log_lik')[[1]][,1:120,]
dim(log_lik) = c(4500, 120 * sum(data.n_forms[items_used]))
loo::waic(log_lik)
ODD@cIndies
